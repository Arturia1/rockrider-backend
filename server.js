const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
const rateLimit = require('express-rate-limit');
require('dotenv').config();

// Importar middlewares customizados
const { 
  auditMiddleware, 
  securityAuditMiddleware, 
  userRateLimitMiddleware,
  actionLogMiddleware,
  timestampMiddleware,
  performanceLogMiddleware
} = require('./src/middleware/audit');

const app = express();
const PORT = process.env.PORT || 3000;

// üîß LOGS DE INICIALIZA√á√ÉO
console.log('\nüé∏ ================================');
console.log('üöÄ Iniciando RockRider Backend...');
console.log('üìÖ Data:', new Date().toISOString());
console.log('üåç NODE_ENV:', process.env.NODE_ENV || 'development');
console.log('‚öôÔ∏è Porta:', PORT);
console.log('üîë JWT_SECRET:', process.env.JWT_SECRET ? 'Configurado ‚úÖ' : 'Usando padr√£o ‚ö†Ô∏è');
console.log('üóÑÔ∏è MongoDB URI:', process.env.MONGODB_URI || 'mongodb://localhost:27017/rockrider');
console.log('üìß Email configurado:', process.env.EMAIL_USER ? 'Sim ‚úÖ' : 'N√£o ‚ö†Ô∏è');
console.log('üé∏ ================================\n');

// ========================================
// üõ°Ô∏è MIDDLEWARES DE SEGURAN√áA
// ========================================

// Middleware de timestamp (primeiro de todos)
app.use(timestampMiddleware);

// Middleware de performance
app.use(performanceLogMiddleware);

// Middleware de auditoria de seguran√ßa
app.use(securityAuditMiddleware);

// Middlewares de seguran√ßa b√°sicos
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
}));
app.use(compression());
console.log('‚úÖ Middlewares de seguran√ßa configurados');

// ========================================
// üö¶ RATE LIMITING
// ========================================

// Rate limiting global - mais permissivo em desenvolvimento
const globalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: process.env.NODE_ENV === 'production' ? 100 : 1000, // Mais requests em dev
  message: {
    error: 'Rate limit excedido',
    message: 'Muitas tentativas, tente novamente em 15 minutos',
    retryAfter: 15 * 60
  },
  handler: (req, res) => {
    console.log('üö´ Rate limit global atingido para IP:', req.ip, 'Rota:', req.originalUrl);
    res.status(429).json({
      error: 'Muitas tentativas',
      message: 'Tente novamente em 15 minutos',
      retryAfter: 15 * 60
    });
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Rate limiting espec√≠fico para autentica√ß√£o
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: process.env.NODE_ENV === 'production' ? 10 : 50, // Mais restrito para auth
  message: {
    error: 'Muitas tentativas de login',
    message: 'Muitas tentativas de autentica√ß√£o. Tente novamente em 15 minutos.',
    retryAfter: 15 * 60
  },
  handler: (req, res) => {
    console.warn('üö® Rate limit de autentica√ß√£o atingido:', {
      ip: req.ip,
      url: req.originalUrl,
      userAgent: req.headers['user-agent']
    });
    res.status(429).json({
      error: 'Muitas tentativas de autentica√ß√£o',
      message: 'Tente novamente em 15 minutos',
      retryAfter: 15 * 60
    });
  }
});

app.use('/api/', globalLimiter);
app.use('/api/auth/login', authLimiter);
app.use('/api/auth/register', authLimiter);
app.use('/api/auth/forgot-password', authLimiter);
console.log('‚úÖ Rate limiting configurado');

// ========================================
// üåê CORS E PARSING
// ========================================

// CORS
const allowedOrigins = [
  'http://localhost:19006',       // Web local
  'exp://192.168.0.8:19000',      // Expo Go app
  'https://rockrider.vercel.app', // caso use Vercel para Web
  'https://rockrider-api.onrender.com' // caso backend fa√ßa chamadas internas
];

app.use(cors({
  origin: (origin, callback) => {
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error(`‚õî Origem n√£o permitida pelo CORS: ${origin}`));
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));

// Body parser
app.use(express.json({ 
  limit: '10mb',
  verify: (req, res, buf) => {
    try {
      JSON.parse(buf);
    } catch (e) {
      console.log('‚ùå JSON inv√°lido recebido de IP:', req.ip);
      res.status(400).json({ error: 'JSON inv√°lido' });
      return;
    }
  }
}));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));
console.log('‚úÖ Body parser configurado');

// ========================================
// üîß MIDDLEWARE DE DEBUG (DESENVOLVIMENTO)
// ========================================

if (process.env.NODE_ENV !== 'production') {
  app.use('/api', (req, res, next) => {
    const startTime = Date.now();
    
    console.log('\nüîµ ================================');
    console.log(`üì• ${req.method} ${req.originalUrl}`);
    console.log(`‚è∞ ${new Date().toISOString()}`);
    console.log(`üåê IP: ${req.ip}`);
    console.log(`üì± ID: ${req.requestId}`);
    console.log(`üîë Auth: ${req.headers.authorization ? 'Bearer ' + req.headers.authorization.substring(7, 20) + '...' : 'Ausente'}`);
    console.log(`üéØ User-Agent: ${req.headers['user-agent']?.substring(0, 50)}...`);
    
    if (req.body && Object.keys(req.body).length > 0) {
      // Sanitizar dados sens√≠veis nos logs
      const sanitizedBody = { ...req.body };
      const sensitiveFields = ['password', 'newPassword', 'currentPassword'];
      sensitiveFields.forEach(field => {
        if (sanitizedBody[field]) {
          sanitizedBody[field] = '[HIDDEN]';
        }
      });
      console.log('üìã Body:', JSON.stringify(sanitizedBody, null, 2));
    }
    
    if (req.query && Object.keys(req.query).length > 0) {
      console.log('üîç Query:', req.query);
    }

    if (req.params && Object.keys(req.params).length > 0) {
      console.log('üìå Params:', req.params);
    }

    // Override res.json para capturar resposta
    const originalJson = res.json;
    
    res.json = function(body) {
      const endTime = Date.now();
      const duration = endTime - startTime;
      
      console.log(`üì§ ${res.statusCode} em ${duration}ms`);
      
      if (res.statusCode >= 400) {
        console.log('‚ùå Resposta de Erro:');
        console.log(JSON.stringify(body, null, 2));
      } else {
        console.log('‚úÖ Resposta de Sucesso');
        if (body && typeof body === 'object') {
          // Log apenas parte da resposta para n√£o poluir
          const preview = { ...body };
          if (preview.posts && Array.isArray(preview.posts)) {
            preview.posts = `[${preview.posts.length} posts]`;
          }
          if (preview.users && Array.isArray(preview.users)) {
            preview.users = `[${preview.users.length} users]`;
          }
          if (preview.token) {
            preview.token = '[TOKEN_HIDDEN]';
          }
          console.log('üìä Preview:', JSON.stringify(preview, null, 2));
        }
      }
      console.log('üîµ ================================\n');
      
      return originalJson.call(this, body);
    };

    next();
  });
  console.log('üîß Debug middleware ativado para desenvolvimento');
}

// ========================================
// üìä MIDDLEWARE DE DADOS DE SESS√ÉO
// ========================================

// Middleware para capturar dados de sess√£o
app.use((req, res, next) => {
  req.sessionData = {
    ip: req.ip,
    userAgent: req.headers['user-agent'],
    timestamp: new Date().toISOString(),
    method: req.method,
    url: req.originalUrl,
    requestId: req.requestId
  };
  next();
});

// Log de requisi√ß√µes importantes (apenas em desenvolvimento)
if (process.env.NODE_ENV !== 'production') {
  app.use('/api/auth', (req, res, next) => {
    console.log(`üîê Auth Request: ${req.method} ${req.originalUrl} from ${req.ip} [${req.requestId}]`);
    next();
  });
}

// ========================================
// üóÑÔ∏è CONEX√ÉO COM MONGODB
// ========================================

const connectDB = async () => {
  try {
    console.log('üîå Conectando ao MongoDB...');
    
    const mongoUri = process.env.MONGODB_URI || 'mongodb://localhost:27017/rockrider';
    console.log('üìç URI:', mongoUri);
    
    const conn = await mongoose.connect(mongoUri, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    
    console.log('‚úÖ MongoDB conectado com sucesso!');
    console.log('üè∑Ô∏è Database:', conn.connection.db.databaseName);
    console.log('üåê Host:', conn.connection.host);
    console.log('üîå Port:', conn.connection.port);
    console.log('üìä ReadyState:', conn.connection.readyState, '(1 = conectado)');
    
    // Verificar collections existentes
    const collections = await conn.connection.db.listCollections().toArray();
    console.log('üìö Collections encontradas:', collections.map(c => c.name));
    
    // Contar documentos nas collections principais
    try {
      const User = require('./src/models/User');
      const Post = require('./src/models/Post');
      
      const userCount = await User.countDocuments();
      const postCount = await Post.countDocuments();
      
      console.log('üë• Total de usu√°rios:', userCount);
      console.log('üìù Total de posts:', postCount);
      
      if (userCount === 0) {
        console.log('‚ö†Ô∏è Aviso: Nenhum usu√°rio encontrado. Registre-se no app para criar dados.');
      }
      
    } catch (modelError) {
      console.log('‚ö†Ô∏è N√£o foi poss√≠vel contar documentos:', modelError.message);
    }
    
  } catch (error) {
    console.error('\n‚ùå ================================');
    console.error('üí• ERRO ao conectar MongoDB:');
    console.error('üìÑ Mensagem:', error.message);
    console.error('üè∑Ô∏è Tipo:', error.name);
    console.error('üìö Stack:', error.stack);
    console.error('‚ùå ================================\n');
    
    console.log('üí° DICAS PARA RESOLVER:');
    console.log('   1. Verifique se MongoDB est√° rodando:');
    console.log('      Windows: services.msc ‚Üí MongoDB Server');
    console.log('      Mac: brew services start mongodb-community');
    console.log('      Linux: sudo systemctl start mongod');
    console.log('   2. Teste conex√£o manual: mongo --eval "db.runCommand(\'ping\')"');
    console.log('   3. Verifique a URI de conex√£o no .env');
    console.log('   4. Verifique permiss√µes de rede/firewall\n');
    
    process.exit(1);
  }
};

// Conectar ao banco
connectDB();

// Listeners para eventos do MongoDB
mongoose.connection.on('error', err => {
  console.error('‚ùå Erro de conex√£o MongoDB:', err);
});

mongoose.connection.on('disconnected', () => {
  console.log('üîå MongoDB desconectado');
});

mongoose.connection.on('reconnected', () => {
  console.log('üîÑ MongoDB reconectado');
});

// ========================================
// üìÇ ROTAS
// ========================================

let authRoutes, userRoutes, postRoutes, eventRoutes;

try {
  console.log('üìÇ Carregando rotas...');
  
  authRoutes = require('./src/routes/auth');
  console.log('‚úÖ Rotas de auth carregadas');
  
  userRoutes = require('./src/routes/users');
  console.log('‚úÖ Rotas de users carregadas');
  
  postRoutes = require('./src/routes/posts');
  console.log('‚úÖ Rotas de posts carregadas');
  
  eventRoutes = require('./src/routes/events');
  console.log('‚úÖ Rotas de events carregadas');
  
} catch (error) {
  console.error('\n‚ùå ================================');
  console.error('üí• ERRO ao carregar rotas:');
  console.error('üìÑ Mensagem:', error.message);
  console.error('üìö Stack:', error.stack);
  console.error('‚ùå ================================\n');
  
  console.log('üí° Verifique se todos os arquivos de rota existem em src/routes/');
  process.exit(1);
}

// Aplicar middleware de rate limiting espec√≠fico para usu√°rios autenticados
app.use('/api/posts', userRateLimitMiddleware());
app.use('/api/users', userRateLimitMiddleware());
app.use('/api/events', userRateLimitMiddleware());

// Registrar rotas
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/posts', postRoutes);
app.use('/api/events', eventRoutes);

console.log('‚úÖ Todas as rotas registradas com sucesso');

// ========================================
// üè• HEALTH CHECK MELHORADO
// ========================================

app.get('/api/health', async (req, res) => {
  try {
    const dbStatus = mongoose.connection.readyState;
    const dbStatusText = {
      0: 'Desconectado',
      1: 'Conectado', 
      2: 'Conectando',
      3: 'Desconectando'
    }[dbStatus];
    
    // Contar usu√°rios ativos (√∫ltimas 24h)
    let activeUsers = 0;
    let totalUsers = 0;
    let totalPosts = 0;
    let dbTestSuccess = false;
    
    try {
      const User = require('./src/models/User');
      const Post = require('./src/models/Post');
      
      totalUsers = await User.countDocuments({ isActive: true });
      totalPosts = await Post.countDocuments({ isActive: true });
      
      // Simular usu√°rios ativos (em uma implementa√ß√£o real, seria baseado em lastLoginAt)
      activeUsers = Math.floor(totalUsers * 0.3); // 30% dos usu√°rios como "ativos"
      
      dbTestSuccess = true;
      
    } catch (dbError) {
      console.log('‚ö†Ô∏è Health check - erro ao acessar collections:', dbError.message);
    }
    
    const healthData = {
      message: 'üé∏ RockRider API est√° funcionando!',
      timestamp: new Date().toISOString(),
      uptime: `${Math.floor(process.uptime())}s`,
      memory: {
        used: `${Math.round(process.memoryUsage().heapUsed / 1024 / 1024)}MB`,
        total: `${Math.round(process.memoryUsage().heapTotal / 1024 / 1024)}MB`,
        usage: `${Math.round((process.memoryUsage().heapUsed / process.memoryUsage().heapTotal) * 100)}%`
      },
      database: {
        status: dbStatusText,
        connected: dbStatus === 1,
        testSuccess: dbTestSuccess
      },
      stats: {
        totalUsers: totalUsers,
        activeUsers: activeUsers,
        totalPosts: totalPosts,
        environment: process.env.NODE_ENV || 'development'
      },
      auth: {
        jwtConfigured: !!process.env.JWT_SECRET,
        tokenExpiry: '7 days',
        rateLimitingActive: true
      },
      features: {
        emailService: !!process.env.EMAIL_USER,
        passwordReset: true,
        userRegistration: true,
        postManagement: true,
        eventManagement: true
      },
      version: '1.0.0'
    };
    
    console.log('üíö Health check executado com sucesso');
    res.json(healthData);
    
  } catch (error) {
    console.log('üíî Health check falhou:', error.message);
    res.status(500).json({ 
      message: 'üíî API com problemas',
      error: error.message,
      timestamp: new Date().toISOString(),
      uptime: `${Math.floor(process.uptime())}s`
    });
  }
});

// ========================================
// üîç ROTA PARA ESTAT√çSTICAS (DESENVOLVIMENTO)
// ========================================

if (process.env.NODE_ENV !== 'production') {
  app.get('/api/stats', async (req, res) => {
    try {
      const User = require('./src/models/User');
      const Post = require('./src/models/Post');
      
      const userStats = await User.aggregate([
        { $group: { _id: '$userType', count: { $sum: 1 } } }
      ]);
      
      const postStats = await Post.aggregate([
        { $group: { _id: '$type', count: { $sum: 1 } } }
      ]);
      
      res.json({
        users: userStats,
        posts: postStats,
        timestamp: new Date().toISOString()
      });
      
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });
}

// ========================================
// üö´ MIDDLEWARE PARA ROTAS N√ÉO ENCONTRADAS
// ========================================

app.use('*', (req, res) => {
  console.log(`üîç Rota n√£o encontrada: ${req.method} ${req.originalUrl} - IP: ${req.ip} [${req.requestId}]`);
  res.status(404).json({ 
    error: 'Rota n√£o encontrada',
    message: `${req.method} ${req.originalUrl} n√£o existe nesta API`,
    requestId: req.requestId,
    timestamp: new Date().toISOString(),
    availableRoutes: [
      'GET /api/health',
      'POST /api/auth/login',
      'POST /api/auth/logout',
      'POST /api/auth/register', 
      'GET /api/posts/feed',
      'POST /api/posts',
      'GET /api/users/search',
      'GET /api/events'
    ]
  });
});

// ========================================
// üö® MIDDLEWARE GLOBAL DE TRATAMENTO DE ERROS
// ========================================

app.use((err, req, res, next) => {
  console.error('\nüö® ================================');
  console.error('‚ùå ERRO GLOBAL CAPTURADO:');
  console.error('üìç URL:', req.method, req.originalUrl);
  console.error('üì± Request ID:', req.requestId);
  console.error('üë§ User ID:', req.user?.userId || 'N√£o autenticado');
  console.error('üë§ User Name:', req.currentUser?.name || 'N/A');
  console.error('üåê IP:', req.ip);
  console.error('üîë Auth Header:', req.headers.authorization ? 'Presente' : 'Ausente');
  console.error('‚è∞ Timestamp:', new Date().toISOString());
  console.error('\nüí• DETALHES DO ERRO:');
  console.error('üìÑ Mensagem:', err.message);
  console.error('üè∑Ô∏è Tipo:', err.name);
  console.error('üî¢ C√≥digo:', err.code);
  console.error('üìö Stack Trace:');
  console.error(err.stack);
  console.error('üö® ================================\n');
  
  // Tratamento espec√≠fico por tipo de erro
  if (err.name === 'ValidationError') {
    return res.status(400).json({
      error: 'Dados inv√°lidos',
      message: 'Erro de valida√ß√£o dos dados enviados',
      requestId: req.requestId,
      details: Object.values(err.errors).map(e => ({
        field: e.path,
        message: e.message,
        value: e.value
      }))
    });
  }
  
  if (err.name === 'JsonWebTokenError') {
    return res.status(401).json({
      error: 'Token inv√°lido',
      message: 'Token JWT malformado ou inv√°lido. Fa√ßa login novamente.',
      code: 'INVALID_TOKEN',
      requestId: req.requestId
    });
  }
  
  if (err.name === 'TokenExpiredError') {
    return res.status(401).json({
      error: 'Token expirado',
      message: 'Sua sess√£o expirou. Fa√ßa login novamente.',
      code: 'TOKEN_EXPIRED',
      requestId: req.requestId
    });
  }
  
  if (err.name === 'CastError' && err.kind === 'ObjectId') {
    return res.status(400).json({
      error: 'ID inv√°lido',
      message: 'Formato de ID MongoDB inv√°lido',
      requestId: req.requestId
    });
  }
  
  if (err.code === 11000) {
    const field = Object.keys(err.keyPattern)[0];
    return res.status(400).json({
      error: 'Dados duplicados',
      message: `${field} j√° est√° em uso`,
      requestId: req.requestId
    });
  }

  if (err.name === 'MongoNetworkError' || err.name === 'MongooseServerSelectionError') {
    return res.status(503).json({
      error: 'Problema de conex√£o com banco de dados',
      message: 'Tente novamente em alguns instantes',
      requestId: req.requestId
    });
  }

  // Erro gen√©rico 500
  res.status(err.status || 500).json({
    error: 'Erro interno do servidor',
    message: process.env.NODE_ENV === 'development' ? err.message : 'Algo deu errado no servidor',
    requestId: req.requestId,
    timestamp: new Date().toISOString(),
    ...(process.env.NODE_ENV === 'development' && { 
      type: err.name,
      stack: err.stack.split('\n').slice(0, 5) // Primeiras 5 linhas do stack
    })
  });
});

// ========================================
// üöÄ INICIAR SERVIDOR
// ========================================

const server = app.listen(PORT, () => {
  console.log('\nüéâ ================================');
  console.log('üöÄ RockRider Backend Online!');
  console.log(`üåê URL: http://localhost:${PORT}`);
  console.log(`üè• Health: http://localhost:${PORT}/api/health`);
  console.log(`üìä Stats: http://localhost:${PORT}/api/stats`);
  console.log(`üîß Debug: ${process.env.NODE_ENV !== 'production' ? 'ATIVADO' : 'DESATIVADO'}`);
  console.log(`üìä MongoDB: ${mongoose.connection.readyState === 1 ? 'Conectado ‚úÖ' : 'Problema ‚ùå'}`);
  console.log(`‚è∞ Iniciado em: ${new Date().toLocaleString('pt-BR')}`);
  console.log('üéâ ================================\n');
  
  console.log('üí° RECURSOS DISPON√çVEIS:');
  console.log('   ‚Ä¢ Health Check: http://localhost:' + PORT + '/api/health');
  console.log('   ‚Ä¢ Autentica√ß√£o com logout melhorado');
  console.log('   ‚Ä¢ Rate limiting inteligente');
  console.log('   ‚Ä¢ Auditoria de seguran√ßa');
  console.log('   ‚Ä¢ Logs detalhados de performance');
  console.log('   ‚Ä¢ Middleware de detec√ß√£o de atividade suspeita\n');
});

// ========================================
// üõë GRACEFUL SHUTDOWN
// ========================================

const gracefulShutdown = (signal) => {
  console.log(`\nüõë ${signal} recebido. Iniciando shutdown gracioso...`);
  
  server.close(async (err) => {
    if (err) {
      console.error('‚ùå Erro ao fechar servidor HTTP:', err);
    } else {
      console.log('üì¥ Servidor HTTP fechado com sucesso');
    }
    
    try {
      await mongoose.connection.close();
      console.log('üóÑÔ∏è Conex√£o MongoDB fechada com sucesso');
    } catch (error) {
      console.error('‚ùå Erro ao fechar MongoDB:', error);
    }
    
    console.log('üëã RockRider Backend finalizado graciosamente');
    process.exit(err ? 1 : 0);
  });
  
  // Force close ap√≥s 10 segundos
  setTimeout(() => {
    console.error('‚ö†Ô∏è Timeout atingido. For√ßando fechamento...');
    process.exit(1);
  }, 10000);
};

// Listeners para shutdown gracioso
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

// Capturar erros n√£o tratados
process.on('unhandledRejection', (reason, promise) => {
  console.error('\nüö® PROMISE REJEITADA N√ÉO TRATADA:');
  console.error('Motivo:', reason);
  console.error('Promise:', promise);
  console.error('üö® ================================\n');
});

process.on('uncaughtException', (error) => {
  console.error('\nüö® EXCE√á√ÉO N√ÉO CAPTURADA:');
  console.error('Erro:', error);
  console.error('Stack:', error.stack);
  console.error('üö® ================================\n');
  process.exit(1);
});

module.exports = app;