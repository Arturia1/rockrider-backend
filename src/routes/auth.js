const express = require('express');
const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const { body, validationResult } = require('express-validator');
const User = require('../models/User');
const { auth } = require('../middleware/auth');
const { sendResetPasswordEmail } = require('../utils/emailService');

const router = express.Router();

// Fun√ß√£o para gerar JWT
const generateToken = (userId) => {
  return jwt.sign(
    { userId }, 
    process.env.JWT_SECRET || 'rockrider_secret_key',
    { expiresIn: '7d' }
  );
};

// ========================================
// üîê ROTAS DE AUTENTICA√á√ÉO B√ÅSICA
// ========================================

// @route   POST /api/auth/register
// @desc    Registrar novo usu√°rio
// @access  Public
router.post('/register', [
  body('name')
    .trim()
    .isLength({ min: 2, max: 50 })
    .withMessage('Nome deve ter entre 2 e 50 caracteres'),
  
  body('email')
    .isEmail()
    .normalizeEmail()
    .withMessage('Email inv√°lido'),
  
  body('password')
    .isLength({ min: 6 })
    .withMessage('Senha deve ter pelo menos 6 caracteres'),
  
  body('userType')
    .isIn(['artist', 'fan'])
    .withMessage('Tipo de usu√°rio deve ser "artist" ou "fan"'),
  
  body('artistName')
    .optional()
    .trim()
    .isLength({ max: 100 })
    .withMessage('Nome art√≠stico deve ter no m√°ximo 100 caracteres')
], async (req, res) => {
  try {
    // Verificar erros de valida√ß√£o
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Dados inv√°lidos',
        details: errors.array()
      });
    }

    const { name, email, password, userType, artistName, genres } = req.body;

    // Verificar se usu√°rio j√° existe
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({
        error: 'Email j√° est√° em uso'
      });
    }

    // Criar novo usu√°rio
    const userData = {
      name,
      email,
      password,
      userType
    };

    // Adicionar campos espec√≠ficos para artistas
    if (userType === 'artist') {
      userData.artistName = artistName || name;
      userData.genres = genres || [];
    }

    const user = new User(userData);
    await user.save();

    // Gerar token
    const token = generateToken(user._id);

    // Log de registro
    console.log(`‚úÖ Novo usu√°rio registrado: ${user.name} (${user.email}) - ${userType} - ${new Date().toISOString()}`);

    res.status(201).json({
      message: 'Usu√°rio criado com sucesso',
      token,
      user: user.toPublicJSON()
    });

  } catch (error) {
    console.error('Erro no registro:', error);
    res.status(500).json({
      error: 'Erro interno do servidor',
      message: error.message
    });
  }
});

// @route   POST /api/auth/login
// @desc    Login do usu√°rio
// @access  Public
router.post('/login', [
  body('email')
    .isEmail()
    .normalizeEmail()
    .withMessage('Email inv√°lido'),
  
  body('password')
    .notEmpty()
    .withMessage('Senha √© obrigat√≥ria')
], async (req, res) => {
  try {
    // Verificar erros de valida√ß√£o
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Dados inv√°lidos',
        details: errors.array()
      });
    }

    const { email, password } = req.body;

    // Buscar usu√°rio com senha
    const user = await User.findOne({ email }).select('+password');
    if (!user) {
      return res.status(401).json({
        error: 'Credenciais inv√°lidas'
      });
    }

    // Verificar se usu√°rio est√° ativo
    if (!user.isActive) {
      return res.status(401).json({
        error: 'Conta desativada'
      });
    }

    // Verificar senha
    const isValidPassword = await user.comparePassword(password);
    if (!isValidPassword) {
      return res.status(401).json({
        error: 'Credenciais inv√°lidas'
      });
    }

    // Gerar token
    const token = generateToken(user._id);

    // Log de login
    console.log(`üîë Login realizado: ${user.name} (${user.email}) - IP: ${req.ip} - ${new Date().toISOString()}`);

    res.json({
      message: 'Login realizado com sucesso',
      token,
      user: user.toPublicJSON()
    });

  } catch (error) {
    console.error('Erro no login:', error);
    res.status(500).json({
      error: 'Erro interno do servidor'
    });
  }
});

// @route   POST /api/auth/logout
// @desc    Logout do usu√°rio (com logs de auditoria)
// @access  Private
router.post('/logout', auth, async (req, res) => {
  try {
    const user = req.currentUser;
    const sessionData = {
      ip: req.ip,
      userAgent: req.headers['user-agent'],
      timestamp: new Date().toISOString()
    };
    
    console.log(`üö™ Logout realizado: ${user.name} (${user.email}) - IP: ${req.ip} - ${new Date().toISOString()}`);
    
    // Aqui podemos adicionar logs de auditoria futuramente
    // await LogModel.create({
    //   userId: user._id,
    //   action: 'logout',
    //   timestamp: new Date(),
    //   ip: req.ip,
    //   userAgent: req.headers['user-agent']
    // });

    // TODO: Implementar blacklist de tokens JWT (opcional)
    // await TokenBlacklist.create({
    //   token: req.authToken,
    //   userId: user._id,
    //   reason: 'logout',
    //   expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 dias
    // });

    res.json({
      message: 'Logout realizado com sucesso',
      user: {
        name: user.name,
        email: user.email
      },
      session: sessionData
    });

  } catch (error) {
    console.error('‚ùå Erro no logout:', error);
    res.status(500).json({
      error: 'Erro interno do servidor',
      message: 'N√£o foi poss√≠vel processar o logout'
    });
  }
});

// @route   GET /api/auth/me
// @desc    Obter dados do usu√°rio logado
// @access  Private
router.get('/me', auth, async (req, res) => {
  try {
    const user = await User.findById(req.user.userId)
      .populate('followers', 'name artistName avatar userType')
      .populate('following', 'name artistName avatar userType');

    if (!user) {
      return res.status(404).json({
        error: 'Usu√°rio n√£o encontrado'
      });
    }

    res.json({
      user: user.toPublicJSON()
    });

  } catch (error) {
    console.error('Erro ao buscar usu√°rio:', error);
    res.status(500).json({
      error: 'Erro interno do servidor'
    });
  }
});

// ========================================
// üë§ ROTAS DE GERENCIAMENTO DE PERFIL
// ========================================

// @route   PUT /api/auth/profile
// @desc    Atualizar perfil do usu√°rio
// @access  Private
router.put('/profile', auth, [
  body('name')
    .optional()
    .trim()
    .isLength({ min: 2, max: 50 })
    .withMessage('Nome deve ter entre 2 e 50 caracteres'),
  
  body('bio')
    .optional()
    .trim()
    .isLength({ max: 500 })
    .withMessage('Bio deve ter no m√°ximo 500 caracteres'),
  
  body('artistName')
    .optional()
    .trim()
    .isLength({ max: 100 })
    .withMessage('Nome art√≠stico deve ter no m√°ximo 100 caracteres')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Dados inv√°lidos',
        details: errors.array()
      });
    }

    const allowedUpdates = ['name', 'bio', 'artistName', 'genres', 'socialLinks'];
    const updates = {};

    // Filtrar apenas campos permitidos
    Object.keys(req.body).forEach(key => {
      if (allowedUpdates.includes(key)) {
        updates[key] = req.body[key];
      }
    });

    const user = await User.findByIdAndUpdate(
      req.user.userId,
      updates,
      { new: true, runValidators: true }
    );

    if (!user) {
      return res.status(404).json({
        error: 'Usu√°rio n√£o encontrado'
      });
    }

    console.log(`üìù Perfil atualizado: ${user.name} (${user.email}) - ${new Date().toISOString()}`);

    res.json({
      message: 'Perfil atualizado com sucesso',
      user: user.toPublicJSON()
    });

  } catch (error) {
    console.error('Erro ao atualizar perfil:', error);
    res.status(500).json({
      error: 'Erro interno do servidor'
    });
  }
});

// @route   POST /api/auth/change-password
// @desc    Alterar senha
// @access  Private
router.post('/change-password', auth, [
  body('currentPassword')
    .notEmpty()
    .withMessage('Senha atual √© obrigat√≥ria'),
  
  body('newPassword')
    .isLength({ min: 6 })
    .withMessage('Nova senha deve ter pelo menos 6 caracteres')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Dados inv√°lidos',
        details: errors.array()
      });
    }

    const { currentPassword, newPassword } = req.body;

    const user = await User.findById(req.user.userId).select('+password');
    if (!user) {
      return res.status(404).json({
        error: 'Usu√°rio n√£o encontrado'
      });
    }

    // Verificar senha atual
    const isValidPassword = await user.comparePassword(currentPassword);
    if (!isValidPassword) {
      return res.status(400).json({
        error: 'Senha atual incorreta'
      });
    }

    // Atualizar senha
    user.password = newPassword;
    await user.save();

    console.log(`üîê Senha alterada: ${user.name} (${user.email}) - ${new Date().toISOString()}`);

    // TODO: Invalidar todos os tokens existentes do usu√°rio
    // await TokenBlacklist.updateMany(
    //   { userId: user._id },
    //   { reason: 'password_change' }
    // );

    res.json({
      message: 'Senha alterada com sucesso'
    });

  } catch (error) {
    console.error('Erro ao alterar senha:', error);
    res.status(500).json({
      error: 'Erro interno do servidor'
    });
  }
});

// ========================================
// üîç ROTAS DE VALIDA√á√ÉO
// ========================================

// @route   POST /api/auth/check-email
// @desc    Verificar disponibilidade do email
// @access  Public
router.post('/check-email', [
  body('email')
    .isEmail()
    .normalizeEmail()
    .withMessage('Email inv√°lido')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Email inv√°lido',
        details: errors.array()
      });
    }

    const { email } = req.body;

    // Verificar se usu√°rio j√° existe
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({
        error: 'Email j√° est√° em uso',
        available: false
      });
    }

    res.json({
      message: 'Email dispon√≠vel',
      available: true
    });

  } catch (error) {
    console.error('Erro ao verificar email:', error);
    res.status(500).json({
      error: 'Erro interno do servidor'
    });
  }
});

// ========================================
// üîê ROTAS DE RESET DE SENHA
// ========================================

// @route   POST /api/auth/forgot-password
// @desc    Solicitar reset de senha - verifica email e envia para a conta espec√≠fica
// @access  Public
router.post('/forgot-password', [
  body('email')
    .isEmail()
    .normalizeEmail()
    .withMessage('Email inv√°lido')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Email inv√°lido',
        details: errors.array()
      });
    }

    const { email } = req.body;

    console.log('üîç Verificando se email existe:', email);

    // 1. Verificar se usu√°rio existe no banco
    const user = await User.findOne({ email });
    
    if (!user) {
      console.log('‚ùå Email n√£o encontrado no banco:', email);
      
      // Por seguran√ßa, sempre retorna sucesso mesmo se email n√£o existir
      // Isso evita que atacantes descobram quais emails est√£o cadastrados
      return res.json({
        message: 'Se este email estiver cadastrado, voc√™ receber√° instru√ß√µes para redefinir sua senha.',
        success: true
      });
    }

    console.log('‚úÖ Usu√°rio encontrado:', user.name, '(' + user.email + ')');

    // 2. Verificar se usu√°rio est√° ativo
    if (!user.isActive) {
      console.log('‚ùå Conta desativada:', email);
      return res.status(400).json({
        error: 'Conta desativada. Entre em contato com o suporte.'
      });
    }

    // 3. Gerar token de reset (10 minutos)
    const resetToken = user.createPasswordResetToken();
    await user.save({ validateBeforeSave: false });

    console.log('üîë Token gerado para:', user.email);
    console.log('‚è∞ Expira em: 10 minutos');

    try {
      // 4. Enviar email para O EMAIL DO USU√ÅRIO que esqueceu a senha
      await sendResetPasswordEmail(
        user.email,    // üìß Email DO USU√ÅRIO (n√£o email do sistema)
        user.name,     // üë§ Nome do usu√°rio
        resetToken     // üîë Token √∫nico
      );

      console.log('‚úÖ Email de reset enviado com sucesso para:', user.email);

      res.json({
        message: 'Instru√ß√µes para redefinir sua senha foram enviadas para seu email.',
        success: true,
        // Informa√ß√µes n√£o-sens√≠veis para o frontend
        info: {
          emailSent: true,
          expiresInMinutes: 10,
          sentTo: user.email.replace(/(.{2}).*(@.*)/, '$1***$2') // Mascarar email: jo***@gmail.com
        }
      });

    } catch (emailError) {
      // Se falhar ao enviar email, limpar token
      user.clearPasswordReset();
      await user.save({ validateBeforeSave: false });

      console.error('‚ùå Erro ao enviar email para:', user.email);
      console.error('‚ùå Detalhes:', emailError.message);
      
      return res.status(500).json({
        error: 'Erro ao enviar email. Tente novamente mais tarde.',
        details: process.env.NODE_ENV === 'development' ? emailError.message : undefined
      });
    }

  } catch (error) {
    console.error('‚ùå Erro no forgot-password:', error);
    res.status(500).json({
      error: 'Erro interno do servidor'
    });
  }
});

// @route   POST /api/auth/validate-reset-token
// @desc    Validar token de reset antes de mostrar formul√°rio
// @access  Public
router.post('/validate-reset-token', [
  body('token')
    .notEmpty()
    .withMessage('Token √© obrigat√≥rio')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Token √© obrigat√≥rio',
        details: errors.array()
      });
    }

    const { token } = req.body;

    // Hash do token
    const hashedToken = crypto
      .createHash('sha256')
      .update(token)
      .digest('hex');

    // Buscar usu√°rio com token v√°lido
    const user = await User.findOne({
      resetPasswordToken: hashedToken,
      resetPasswordExpires: { $gt: Date.now() }
    });

    if (!user) {
      return res.status(400).json({
        error: 'Token inv√°lido ou expirado',
        valid: false,
        message: 'Este link de redefini√ß√£o √© inv√°lido ou expirou. Solicite um novo.'
      });
    }

    if (!user.isActive) {
      return res.status(400).json({
        error: 'Conta desativada',
        valid: false,
        message: 'Conta desativada. Entre em contato com o suporte.'
      });
    }

    // Calcular tempo restante
    const timeRemaining = Math.max(0, user.resetPasswordExpires - Date.now());
    const minutesRemaining = Math.floor(timeRemaining / (1000 * 60));

    res.json({
      valid: true,
      message: 'Token v√°lido',
      user: {
        name: user.name,
        email: user.email
      },
      expiresIn: minutesRemaining
    });

  } catch (error) {
    console.error('Erro ao validar token:', error);
    res.status(500).json({
      error: 'Erro interno do servidor',
      valid: false
    });
  }
});

// @route   POST /api/auth/reset-password
// @desc    Redefinir senha com token
// @access  Public
router.post('/reset-password', [
  body('token')
    .notEmpty()
    .withMessage('Token de reset √© obrigat√≥rio'),
  
  body('newPassword')
    .isLength({ min: 6 })
    .withMessage('Nova senha deve ter pelo menos 6 caracteres')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Dados inv√°lidos',
        details: errors.array()
      });
    }

    const { token, newPassword } = req.body;

    // Hash do token para comparar com o banco
    const hashedToken = crypto
      .createHash('sha256')
      .update(token)
      .digest('hex');

    // Buscar usu√°rio com token v√°lido e n√£o expirado
    const user = await User.findOne({
      resetPasswordToken: hashedToken,
      resetPasswordExpires: { $gt: Date.now() }
    });

    if (!user) {
      return res.status(400).json({
        error: 'Token inv√°lido ou expirado',
        message: 'Solicite um novo link de redefini√ß√£o de senha.'
      });
    }

    // Verificar se usu√°rio est√° ativo
    if (!user.isActive) {
      return res.status(400).json({
        error: 'Conta desativada. Entre em contato com o suporte.'
      });
    }

    // Atualizar senha
    user.password = newPassword;
    user.clearPasswordReset();
    await user.save();

    // Gerar novo token JWT para login autom√°tico
    const jwtToken = generateToken(user._id);

    console.log(`üîê Senha redefinida via reset: ${user.name} (${user.email}) - ${new Date().toISOString()}`);

    res.json({
      message: 'Senha redefinida com sucesso! Voc√™ foi logado automaticamente.',
      success: true,
      token: jwtToken,
      user: user.toPublicJSON()
    });

  } catch (error) {
    console.error('Erro no reset-password:', error);
    res.status(500).json({
      error: 'Erro interno do servidor'
    });
  }
});

// ========================================
// üß™ ROTAS DE TESTE
// ========================================

router.get('/test-jwt', (req, res) => {
  const secret = process.env.JWT_SECRET || 'rockrider_secret_key';
  
  // Criar token de teste
  const testToken = jwt.sign({ userId: 'test123' }, secret);
  
  // Verificar token de teste
  try {
    const decoded = jwt.verify(testToken, secret);
    res.json({
      success: true,
      secret: secret,
      tokenWorks: true,
      decoded: decoded
    });
  } catch (error) {
    res.json({
      success: false,
      secret: secret,
      tokenWorks: false,
      error: error.message
    });
  }
});

// @route   POST /api/auth/logout
// @desc    Logout do usu√°rio (com logs de auditoria melhorados)
// @access  Private
router.post('/logout', auth, async (req, res) => {
  try {
    const user = req.currentUser;
    const sessionData = {
      ip: req.ip,
      userAgent: req.headers['user-agent'],
      timestamp: new Date().toISOString(),
      userId: user._id,
      userName: user.name,
      userType: user.userType
    };
    
    console.log(`üö™ Logout iniciado: ${user.name} (${user.email}) - ${user.userType} - IP: ${req.ip} - ${new Date().toISOString()}`);
    
    // Aqui podemos adicionar logs de auditoria futuramente
    // await LogModel.create({
    //   userId: user._id,
    //   action: 'logout',
    //   timestamp: new Date(),
    //   ip: req.ip,
    //   userAgent: req.headers['user-agent'],
    //   success: true
    // });

    // TODO: Implementar blacklist de tokens JWT (opcional para seguran√ßa extra)
    // await TokenBlacklist.create({
    //   token: req.authToken,
    //   userId: user._id,
    //   reason: 'logout',
    //   expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 dias
    // });

    console.log(`‚úÖ Logout conclu√≠do com sucesso: ${user.name} (${user.email})`);

    res.json({
      success: true,
      message: 'Logout realizado com sucesso',
      user: {
        name: user.name,
        email: user.email,
        userType: user.userType
      },
      session: sessionData,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('‚ùå Erro no logout:', error);
    
    // Log do erro para auditoria
    if (req.currentUser) {
      console.error(`‚ùå Erro no logout para ${req.currentUser.name} (${req.currentUser.email}):`, error.message);
    }
    
    // Mesmo com erro, considerar logout bem-sucedido do ponto de vista do cliente
    // Isso evita que usu√°rios fiquem "presos" logados
    res.status(200).json({
      success: true,
      message: 'Logout processado (com avisos internos)',
      warning: 'Houve um problema interno, mas sua sess√£o foi encerrada',
      timestamp: new Date().toISOString()
    });
  }
});

// @route   PUT /api/auth/profile
// @desc    Atualizar perfil do usu√°rio
// @access  Private
router.put('/profile', auth, [
  body('name')
    .optional()
    .trim()
    .isLength({ min: 2, max: 50 })
    .withMessage('Nome deve ter entre 2 e 50 caracteres'),
  
  body('bio')
    .optional()
    .trim()
    .isLength({ max: 500 })
    .withMessage('Bio deve ter no m√°ximo 500 caracteres'),
  
  body('artistName')
    .optional()
    .trim()
    .isLength({ max: 100 })
    .withMessage('Nome art√≠stico deve ter no m√°ximo 100 caracteres'),
    
  // ‚úÖ ADICIONADO: Valida√ß√£o para avatar
  body('avatar')
    .optional()
    .custom((value) => {
      if (!value) return true; // Permitir valor vazio
      try {
        new URL(value);
        return true;
      } catch (error) {
        throw new Error('Avatar deve ser uma URL v√°lida');
      }
    })
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Dados inv√°lidos',
        details: errors.array()
      });
    }

    // ‚úÖ CORRIGIDO: Incluir 'avatar' na lista de campos permitidos
    const allowedUpdates = ['name', 'bio', 'artistName', 'genres', 'socialLinks', 'avatar'];

    const updates = {};

    // Filtrar apenas campos permitidos
    Object.keys(req.body).forEach(key => {
      if (allowedUpdates.includes(key)) {
        updates[key] = req.body[key];
      }
    });

    const user = await User.findByIdAndUpdate(
      req.user.userId,
      updates,
      { new: true, runValidators: true }
    );

    if (!user) {
      return res.status(404).json({
        error: 'Usu√°rio n√£o encontrado'
      });
    }

    console.log(`üìù Perfil atualizado: ${user.name} (${user.email}) - ${new Date().toISOString()}`);
    
    // ‚úÖ ADICIONADO: Log espec√≠fico para avatar
    if (updates.avatar !== undefined) {
      console.log(`üñºÔ∏è Avatar ${updates.avatar ? 'atualizado' : 'removido'}: ${user.name}`);
    }

    res.json({
      message: 'Perfil atualizado com sucesso',
      user: user.toPublicJSON()
    });

  } catch (error) {
    console.error('Erro ao atualizar perfil:', error);
    res.status(500).json({
      error: 'Erro interno do servidor'
    });
  }
});

router.put('/profile', auth, [
  // ... valida√ß√µes
], async (req, res) => {
  try {
    console.log('üîç BACKEND: Dados recebidos:', req.body);
    console.log('üîç BACKEND: Usu√°rio logado:', req.user.userId);

    const allowedUpdates = ['name', 'bio', 'artistName', 'genres', 'socialLinks', 'avatar'];
    const updates = {};

    Object.keys(req.body).forEach(key => {
      if (allowedUpdates.includes(key)) {
        updates[key] = req.body[key];
      }
    });

    console.log('üîç BACKEND: Updates filtrados:', updates);

    const user = await User.findByIdAndUpdate(
      req.user.userId,
      updates,
      { new: true, runValidators: true }
    );

    console.log('üîç BACKEND: Usu√°rio atualizado:', {
      id: user._id,
      name: user.name,
      avatar: user.avatar
    });

    res.json({
      message: 'Perfil atualizado com sucesso',
      user: user.toPublicJSON()
    });

  } catch (error) {
    console.error('üîç BACKEND: Erro:', error);
    res.status(500).json({
      error: 'Erro interno do servidor'
    });
  }
});

module.exports = router;